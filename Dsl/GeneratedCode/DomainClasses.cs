//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass SequenceDiagram
	/// Root element in which others are embedded.
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.SequenceDiagram.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.SequenceDiagram.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("006530fa-ee1b-4661-9948-0603c58ffe0c")]
	public partial class SequenceDiagram : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// SequenceDiagram domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x006530fa, 0xee1b, 0x4661, 0x99, 0x48, 0x06, 0x03, 0xc5, 0x8f, 0xfe, 0x0c);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public SequenceDiagram(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public SequenceDiagram(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Comments opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Comments.
		/// Description for Sawczyn.Sequencer.SequenceDiagramHasComments.SequenceDiagram
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Comment> Comments
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Comment>, Comment>(global::Sawczyn.Sequencer.SequenceDiagramHasComments.SequenceDiagramDomainRoleId);
			}
		}
		#endregion
		#region Classed opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Classed.
		/// Description for Sawczyn.Sequencer.SequenceDiagramHasClasses.SequenceDiagram
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Class> Classed
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Class>, Class>(global::Sawczyn.Sequencer.SequenceDiagramHasClasses.SequenceDiagramDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Sawczyn.Sequencer.Comment.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Sawczyn.Sequencer.Class.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Sawczyn.Sequencer.Comment sourceComment1 = sourceElement as global::Sawczyn.Sequencer.Comment;
			if (sourceComment1 != null)
			{
				// Create link for path SequenceDiagramHasComments.Comments
				this.Comments.Add(sourceComment1);

				return;
			}
				
			global::Sawczyn.Sequencer.Class sourceClass2 = sourceElement as global::Sawczyn.Sequencer.Class;
			if (sourceClass2 != null)
			{
				// Create link for path SequenceDiagramHasClasses.Classed
				this.Classed.Add(sourceClass2);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Sawczyn.Sequencer.Comment sourceComment1 = sourceElement as global::Sawczyn.Sequencer.Comment;
			if (sourceComment1 != null)
			{
				// Delete link for path SequenceDiagramHasComments.Comments
				
				foreach (DslModeling::ElementLink link in global::Sawczyn.Sequencer.SequenceDiagramHasComments.GetLinks((global::Sawczyn.Sequencer.SequenceDiagram)this, sourceComment1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Sawczyn.Sequencer.SequenceDiagramHasComments.SequenceDiagramDomainRoleId, global::Sawczyn.Sequencer.SequenceDiagramHasComments.CommentDomainRoleId);
				}

				return;
			}
				
			global::Sawczyn.Sequencer.Class sourceClass2 = sourceElement as global::Sawczyn.Sequencer.Class;
			if (sourceClass2 != null)
			{
				// Delete link for path SequenceDiagramHasClasses.Classed
				
				foreach (DslModeling::ElementLink link in global::Sawczyn.Sequencer.SequenceDiagramHasClasses.GetLinks((global::Sawczyn.Sequencer.SequenceDiagram)this, sourceClass2))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Sawczyn.Sequencer.SequenceDiagramHasClasses.SequenceDiagramDomainRoleId, global::Sawczyn.Sequencer.SequenceDiagramHasClasses.ClassDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass FlowElement
	/// Elements that can be connected by Flow links.
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.FlowElement.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.FlowElement.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("6b2534e3-0986-43fa-b1b9-95d61b5fe940")]
	public abstract partial class FlowElement : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// FlowElement domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x6b2534e3, 0x0986, 0x43fa, 0xb1, 0xb9, 0x95, 0xd6, 0x1b, 0x5f, 0xe9, 0x40);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected FlowElement(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Comments opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Comments.
		/// Description for Sawczyn.Sequencer.CommentReferencesSubjects.Subject
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Comment> Comments
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Comment>, Comment>(global::Sawczyn.Sequencer.CommentReferencesSubjects.SubjectDomainRoleId);
			}
		}
		#endregion
		#region Class opposite domain role accessor
		/// <summary>
		/// Gets or sets Class.
		/// Description for Sawczyn.Sequencer.ClassHasFlowElements.FlowElement
		/// </summary>
		public virtual Class Class
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Sawczyn.Sequencer.ClassHasFlowElements.FlowElementDomainRoleId) as Class;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Sawczyn.Sequencer.ClassHasFlowElements.FlowElementDomainRoleId, value);
			}
		}
		#endregion
		#region CallTarget opposite domain role accessor
		
		/// <summary>
		/// Gets a list of CallTarget.
		/// Description for Sawczyn.Sequencer.FlowElementsCallCallables.FlowElement
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Callable> CallTarget
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Callable>, Callable>(global::Sawczyn.Sequencer.FlowElementsCallCallables.FlowElementDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Sawczyn.Sequencer.Comment.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Sawczyn.Sequencer.Comment sourceComment1 = sourceElement as global::Sawczyn.Sequencer.Comment;
			if (sourceComment1 != null)
			{
				// Create link for path ClassHasFlowElements.Class/!Class/SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments
						// Segments 0 and 1
						global::Sawczyn.Sequencer.Class this2 = this.Class;
						if ( this2 == null ) throw new global::System.InvalidOperationException("Null encountered while traversing path 'ClassHasFlowElements.Class/!Class/SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments'.");
						// Segments 2 and 3
						global::Sawczyn.Sequencer.SequenceDiagram commentHost0 = this2.SequenceDiagram;
						if ( commentHost0 == null ) throw new global::System.InvalidOperationException("Null encountered while traversing path 'ClassHasFlowElements.Class/!Class/SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments'.");
				commentHost0.Comments.Add(sourceComment1);

				// Create link for path CommentReferencesSubjects.Comments
				this.Comments.Add(sourceComment1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Sawczyn.Sequencer.Comment sourceComment1 = sourceElement as global::Sawczyn.Sequencer.Comment;
			if (sourceComment1 != null)
			{
				// Delete link for path ClassHasFlowElements.Class/!Class/SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments
					// Segments 0 and 1
					global::Sawczyn.Sequencer.Class this2 = this.Class;
					if ( this2 == null ) throw new global::System.InvalidOperationException("Null encountered while traversing path 'ClassHasFlowElements.Class/!Class/SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments'.");
					// Segments 2 and 3
					global::Sawczyn.Sequencer.SequenceDiagram commentHost0 = this2.SequenceDiagram;
					if ( commentHost0 == null ) throw new global::System.InvalidOperationException("Null encountered while traversing path 'ClassHasFlowElements.Class/!Class/SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments'.");
				
				foreach (DslModeling::ElementLink link in global::Sawczyn.Sequencer.SequenceDiagramHasComments.GetLinks((global::Sawczyn.Sequencer.SequenceDiagram)commentHost0, sourceComment1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Sawczyn.Sequencer.SequenceDiagramHasComments.SequenceDiagramDomainRoleId, global::Sawczyn.Sequencer.SequenceDiagramHasComments.CommentDomainRoleId);
				}

				// Delete link for path CommentReferencesSubjects.Comments
				
				foreach (DslModeling::ElementLink link in global::Sawczyn.Sequencer.CommentReferencesSubjects.GetLinks(sourceComment1, (global::Sawczyn.Sequencer.FlowElement)this))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Sawczyn.Sequencer.CommentReferencesSubjects.SubjectDomainRoleId, global::Sawczyn.Sequencer.CommentReferencesSubjects.CommentDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass Method
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Method.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.Method.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("772402eb-0be4-4f60-b20c-f4de33e1296d")]
	public partial class Method : Callable
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Method domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x772402eb, 0x0be4, 0x4f60, 0xb2, 0x0c, 0xf4, 0xde, 0x33, 0xe1, 0x29, 0x6d);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Method(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Method(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0x5f728af3, 0x5188, 0x4754, 0x9a, 0x4f, 0x8c, 0x2c, 0xb8, 0x42, 0xda, 0xd2);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// Description for Sawczyn.Sequencer.Method.Name
		/// </summary>
		[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Method/Name.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Sawczyn.Sequencer.Method/Name.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.DefaultValue("")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("5f728af3-5188-4754-9a4f-8c2cb842dad2")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Method.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<Method, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Method.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Method.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Method element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Method element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region IsStatic domain property code
		
		/// <summary>
		/// IsStatic domain property Id.
		/// </summary>
		public static readonly global::System.Guid IsStaticDomainPropertyId = new global::System.Guid(0x3b2436de, 0xe57f, 0x4138, 0x98, 0xc0, 0x54, 0x97, 0xaf, 0x2c, 0x18, 0x11);
		
		/// <summary>
		/// Storage for IsStatic
		/// </summary>
		private global::System.Boolean isStaticPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of IsStatic domain property.
		/// If true, this is a static method
		/// </summary>
		[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Method/IsStatic.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Sawczyn.Sequencer.Method/IsStatic.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("3b2436de-e57f-4138-98c0-5497af2c1811")]
		public global::System.Boolean IsStatic
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return isStaticPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				IsStaticPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Method.IsStatic domain property.
		/// </summary>
		internal sealed partial class IsStaticPropertyHandler : DslModeling::DomainPropertyValueHandler<Method, global::System.Boolean>
		{
			private IsStaticPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Method.IsStatic domain property value handler.
			/// </summary>
			public static readonly IsStaticPropertyHandler Instance = new IsStaticPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Method.IsStatic domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return IsStaticDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Boolean GetValue(Method element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.isStaticPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Method element, global::System.Boolean newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Boolean oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.isStaticPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass StartPoint
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.StartPoint.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.StartPoint.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("172e1065-b774-4fe9-a636-b1b826fc02f4")]
	public partial class StartPoint : FlowElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// StartPoint domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x172e1065, 0xb774, 0x4fe9, 0xa6, 0x36, 0xb1, 0xb8, 0x26, 0xfc, 0x02, 0xf4);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public StartPoint(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public StartPoint(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass EndPoint
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.EndPoint.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.EndPoint.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("d2517cdc-b6ed-4390-be79-6dbfd058d159")]
	public partial class EndPoint : FlowElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// EndPoint domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xd2517cdc, 0xb6ed, 0x4390, 0xbe, 0x79, 0x6d, 0xbf, 0xd0, 0x58, 0xd1, 0x59);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public EndPoint(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public EndPoint(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass Branch
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Branch.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.Branch.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("c61b1bda-8b86-4ac9-aa39-b5b62221b45f")]
	public partial class Branch : Callable
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Branch domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xc61b1bda, 0x8b86, 0x4ac9, 0xaa, 0x39, 0xb5, 0xb6, 0x22, 0x21, 0xb4, 0x5f);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Branch(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Branch(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass Synchronization
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Synchronization.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.Synchronization.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("fefab4a8-6905-4882-8bcf-9e7d765e30f7")]
	public partial class Synchronization : Callable
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Synchronization domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xfefab4a8, 0x6905, 0x4882, 0x8b, 0xcf, 0x9e, 0x7d, 0x76, 0x5e, 0x30, 0xf7);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Synchronization(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Synchronization(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass Comment
	/// Can be attached to any task flow element.
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Comment.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.Comment.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("70392b8c-b46f-41a6-95e0-f964b3346ac6")]
	public partial class Comment : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Comment domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x70392b8c, 0xb46f, 0x41a6, 0x95, 0xe0, 0xf9, 0x64, 0xb3, 0x34, 0x6a, 0xc6);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Comment(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Comment(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Text domain property code
		
		/// <summary>
		/// Text domain property Id.
		/// </summary>
		public static readonly global::System.Guid TextDomainPropertyId = new global::System.Guid(0xa1f90568, 0x183f, 0x4600, 0xab, 0x87, 0x91, 0x6e, 0x09, 0xf9, 0x16, 0xff);
		
		/// <summary>
		/// Storage for Text
		/// </summary>
		private global::System.String textPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Text domain property.
		/// </summary>
		[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Comment/Text.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Sawczyn.Sequencer.Comment/Text.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.DefaultValue("")]
		[DslModeling::DomainObjectId("a1f90568-183f-4600-ab87-916e09f916ff")]
		public global::System.String Text
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return textPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				TextPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Comment.Text domain property.
		/// </summary>
		internal sealed partial class TextPropertyHandler : DslModeling::DomainPropertyValueHandler<Comment, global::System.String>
		{
			private TextPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Comment.Text domain property value handler.
			/// </summary>
			public static readonly TextPropertyHandler Instance = new TextPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Comment.Text domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return TextDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Comment element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.textPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Comment element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.textPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region SequenceDiagram opposite domain role accessor
		/// <summary>
		/// Gets or sets SequenceDiagram.
		/// Description for Sawczyn.Sequencer.SequenceDiagramHasComments.Comment
		/// </summary>
		public virtual SequenceDiagram SequenceDiagram
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Sawczyn.Sequencer.SequenceDiagramHasComments.CommentDomainRoleId) as SequenceDiagram;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Sawczyn.Sequencer.SequenceDiagramHasComments.CommentDomainRoleId, value);
			}
		}
		#endregion
		#region Subjects opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Subjects.
		/// Description for Sawczyn.Sequencer.CommentReferencesSubjects.Comment
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<FlowElement> Subjects
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<FlowElement>, FlowElement>(global::Sawczyn.Sequencer.CommentReferencesSubjects.CommentDomainRoleId);
			}
		}
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass Class
	/// Represented by a swim lane on the diagram.
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Class.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.Class.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("03d47fa2-49ec-4bdc-966a-f3fd9a2ff69f")]
	public partial class Class : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Class domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x03d47fa2, 0x49ec, 0x4bdc, 0x96, 0x6a, 0xf3, 0xfd, 0x9a, 0x2f, 0xf6, 0x9f);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Class(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Class(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0x47607c73, 0xb450, 0x4318, 0xae, 0x2d, 0x22, 0xf0, 0xc6, 0x3a, 0x9e, 0x9c);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// Description for Sawczyn.Sequencer.Class.Name
		/// </summary>
		[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Class/Name.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Sawczyn.Sequencer.Class/Name.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.DefaultValue("")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("47607c73-b450-4318-ae2d-22f0c63a9e9c")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Class.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<Class, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Class.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Class.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Class element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Class element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Assembly domain property code
		
		/// <summary>
		/// Assembly domain property Id.
		/// </summary>
		public static readonly global::System.Guid AssemblyDomainPropertyId = new global::System.Guid(0x8b255d01, 0x7e68, 0x4b0a, 0x9a, 0xf2, 0xd5, 0x47, 0xbe, 0x9b, 0xeb, 0x79);
		
		/// <summary>
		/// Storage for Assembly
		/// </summary>
		private global::System.String assemblyPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Assembly domain property.
		/// Description for Sawczyn.Sequencer.Class.Assembly
		/// </summary>
		[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Class/Assembly.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Sawczyn.Sequencer.Class/Assembly.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("8b255d01-7e68-4b0a-9af2-d547be9beb79")]
		public global::System.String Assembly
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return assemblyPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				AssemblyPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Class.Assembly domain property.
		/// </summary>
		internal sealed partial class AssemblyPropertyHandler : DslModeling::DomainPropertyValueHandler<Class, global::System.String>
		{
			private AssemblyPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Class.Assembly domain property value handler.
			/// </summary>
			public static readonly AssemblyPropertyHandler Instance = new AssemblyPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Class.Assembly domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return AssemblyDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Class element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.assemblyPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Class element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.assemblyPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region SequenceDiagram opposite domain role accessor
		/// <summary>
		/// Gets or sets SequenceDiagram.
		/// Description for Sawczyn.Sequencer.SequenceDiagramHasClasses.Class
		/// </summary>
		public virtual SequenceDiagram SequenceDiagram
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Sawczyn.Sequencer.SequenceDiagramHasClasses.ClassDomainRoleId) as SequenceDiagram;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Sawczyn.Sequencer.SequenceDiagramHasClasses.ClassDomainRoleId, value);
			}
		}
		#endregion
		#region FlowElements opposite domain role accessor
		
		/// <summary>
		/// Gets a list of FlowElements.
		/// Description for Sawczyn.Sequencer.ClassHasFlowElements.Class
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<FlowElement> FlowElements
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<FlowElement>, FlowElement>(global::Sawczyn.Sequencer.ClassHasFlowElements.ClassDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Sawczyn.Sequencer.Comment.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Sawczyn.Sequencer.Class.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Sawczyn.Sequencer.FlowElement.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Sawczyn.Sequencer.Comment sourceComment1 = sourceElement as global::Sawczyn.Sequencer.Comment;
			if (sourceComment1 != null)
			{
				// Create link for path SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments
						// Segments 0 and 1
						global::Sawczyn.Sequencer.SequenceDiagram commentHost = this.SequenceDiagram;
						if ( commentHost == null ) throw new global::System.InvalidOperationException("Null encountered while traversing path 'SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments'.");
				commentHost.Comments.Add(sourceComment1);

				return;
			}
				
			global::Sawczyn.Sequencer.Class sourceClass2 = sourceElement as global::Sawczyn.Sequencer.Class;
			if (sourceClass2 != null)
			{
				// Create link for path SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/.Classed
						// Segments 0 and 1
						global::Sawczyn.Sequencer.SequenceDiagram classHost = this.SequenceDiagram;
						if ( classHost == null ) throw new global::System.InvalidOperationException("Null encountered while traversing path 'SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/.Classed'.");
				classHost.Classed.Add(sourceClass2);

				return;
			}
				
			global::Sawczyn.Sequencer.FlowElement sourceFlowElement3 = sourceElement as global::Sawczyn.Sequencer.FlowElement;
			if (sourceFlowElement3 != null)
			{
				// Create link for path ClassHasFlowElements.FlowElements
				this.FlowElements.Add(sourceFlowElement3);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Sawczyn.Sequencer.Comment sourceComment1 = sourceElement as global::Sawczyn.Sequencer.Comment;
			if (sourceComment1 != null)
			{
				// Delete link for path SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments
					// Segments 0 and 1
					global::Sawczyn.Sequencer.SequenceDiagram commentHost = this.SequenceDiagram;
					if ( commentHost == null ) throw new global::System.InvalidOperationException("Null encountered while traversing path 'SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/SequenceDiagramHasComments.Comments'.");
				
				foreach (DslModeling::ElementLink link in global::Sawczyn.Sequencer.SequenceDiagramHasComments.GetLinks((global::Sawczyn.Sequencer.SequenceDiagram)commentHost, sourceComment1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Sawczyn.Sequencer.SequenceDiagramHasComments.SequenceDiagramDomainRoleId, global::Sawczyn.Sequencer.SequenceDiagramHasComments.CommentDomainRoleId);
				}

				return;
			}
				
			global::Sawczyn.Sequencer.Class sourceClass2 = sourceElement as global::Sawczyn.Sequencer.Class;
			if (sourceClass2 != null)
			{
				// Delete link for path SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/.Classed
					// Segments 0 and 1
					global::Sawczyn.Sequencer.SequenceDiagram classHost = this.SequenceDiagram;
					if ( classHost == null ) throw new global::System.InvalidOperationException("Null encountered while traversing path 'SequenceDiagramHasClasses.SequenceDiagram/!SequenceDiagram/.Classed'.");
				
				foreach (DslModeling::ElementLink link in global::Sawczyn.Sequencer.SequenceDiagramHasClasses.GetLinks((global::Sawczyn.Sequencer.SequenceDiagram)classHost, sourceClass2))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Sawczyn.Sequencer.SequenceDiagramHasClasses.SequenceDiagramDomainRoleId, global::Sawczyn.Sequencer.SequenceDiagramHasClasses.ClassDomainRoleId);
				}

				return;
			}
				
			global::Sawczyn.Sequencer.FlowElement sourceFlowElement3 = sourceElement as global::Sawczyn.Sequencer.FlowElement;
			if (sourceFlowElement3 != null)
			{
				// Delete link for path ClassHasFlowElements.FlowElements
				
				foreach (DslModeling::ElementLink link in global::Sawczyn.Sequencer.ClassHasFlowElements.GetLinks((global::Sawczyn.Sequencer.Class)this, sourceFlowElement3))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Sawczyn.Sequencer.ClassHasFlowElements.ClassDomainRoleId, global::Sawczyn.Sequencer.ClassHasFlowElements.FlowElementDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Sawczyn.Sequencer
{
	/// <summary>
	/// DomainClass Callable
	/// Description for Sawczyn.Sequencer.Callable
	/// </summary>
	[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Callable.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Sawczyn.Sequencer.Callable.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Sawczyn.Sequencer.SequencerDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("20320173-a436-41a3-a161-e0e99e26ded6")]
	public abstract partial class Callable : FlowElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Callable domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x20320173, 0xa436, 0x41a3, 0xa1, 0x61, 0xe0, 0xe9, 0x9e, 0x26, 0xde, 0xd6);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected Callable(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region ReturnType domain property code
		
		/// <summary>
		/// ReturnType domain property Id.
		/// </summary>
		public static readonly global::System.Guid ReturnTypeDomainPropertyId = new global::System.Guid(0x595474ae, 0xd29b, 0x457b, 0xa5, 0x72, 0xc4, 0xa8, 0x85, 0x4d, 0xa9, 0x9a);
		
		/// <summary>
		/// Storage for ReturnType
		/// </summary>
		private global::System.String returnTypePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of ReturnType domain property.
		/// Description for Sawczyn.Sequencer.Callable.Return Type
		/// </summary>
		[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Callable/ReturnType.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Sawczyn.Sequencer.Callable/ReturnType.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("595474ae-d29b-457b-a572-c4a8854da99a")]
		public global::System.String ReturnType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return returnTypePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ReturnTypePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Callable.ReturnType domain property.
		/// </summary>
		internal sealed partial class ReturnTypePropertyHandler : DslModeling::DomainPropertyValueHandler<Callable, global::System.String>
		{
			private ReturnTypePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Callable.ReturnType domain property value handler.
			/// </summary>
			public static readonly ReturnTypePropertyHandler Instance = new ReturnTypePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Callable.ReturnType domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ReturnTypeDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Callable element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.returnTypePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Callable element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.returnTypePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Condition domain property code
		
		/// <summary>
		/// Condition domain property Id.
		/// </summary>
		public static readonly global::System.Guid ConditionDomainPropertyId = new global::System.Guid(0x637b74b1, 0xc6f2, 0x4219, 0x87, 0xfb, 0xdb, 0xf6, 0xa3, 0xce, 0xe6, 0xa9);
		
		/// <summary>
		/// Storage for Condition
		/// </summary>
		private global::System.String conditionPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Condition domain property.
		/// Description for Sawczyn.Sequencer.Callable.Condition
		/// </summary>
		[DslDesign::DisplayNameResource("Sawczyn.Sequencer.Callable/Condition.DisplayName", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Sawczyn.Sequencer.Callable/Condition.Description", typeof(global::Sawczyn.Sequencer.SequencerDomainModel), "Sawczyn.Sequencer.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("637b74b1-c6f2-4219-87fb-dbf6a3cee6a9")]
		public global::System.String Condition
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return conditionPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				ConditionPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Callable.Condition domain property.
		/// </summary>
		internal sealed partial class ConditionPropertyHandler : DslModeling::DomainPropertyValueHandler<Callable, global::System.String>
		{
			private ConditionPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Callable.Condition domain property value handler.
			/// </summary>
			public static readonly ConditionPropertyHandler Instance = new ConditionPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Callable.Condition domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return ConditionDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Callable element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.conditionPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Callable element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.conditionPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region CallSource opposite domain role accessor
		
		/// <summary>
		/// Gets a list of CallSource.
		/// Description for Sawczyn.Sequencer.FlowElementsCallCallables.Callable
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<FlowElement> CallSource
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<FlowElement>, FlowElement>(global::Sawczyn.Sequencer.FlowElementsCallCallables.CallableDomainRoleId);
			}
		}
		#endregion
		#region ResultTarget opposite domain role accessor
		
		/// <summary>
		/// Gets a list of ResultTarget.
		/// Description for Sawczyn.Sequencer.CallablesReturnResults.SourceCallable
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Callable> ResultTarget
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Callable>, Callable>(global::Sawczyn.Sequencer.CallablesReturnResults.SourceCallableDomainRoleId);
			}
		}
		#endregion
		#region ResultSource opposite domain role accessor
		
		/// <summary>
		/// Gets a list of ResultSource.
		/// Description for Sawczyn.Sequencer.CallablesReturnResults.TargetCallable
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Callable> ResultSource
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Callable>, Callable>(global::Sawczyn.Sequencer.CallablesReturnResults.TargetCallableDomainRoleId);
			}
		}
		#endregion
	}
}
